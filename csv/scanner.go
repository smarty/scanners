// Package csv scans CSV files, provides easy access to individual
// columns, and can also read field values into a struct (analogous
// to unmarshaling JSON or XML).
//
// It thinly wraps the standard library's [csv.Reader] and exposes
// most of its configuration "knobs" and behavior. Knowledge of
// the csv.Reader will help in configuring and running these
// scanners.
//
// Advance the scanners with the Scan method and check errors with
// the Error method (unlike fields and fixedwidth, which use Err).
package csv

import (
	"encoding/csv"
	"io"
)

// Scanner provides access to the fields of CSV-encoded data.
//
// All configurations of the underlying *csv.Reader are available
// through an [Option].
type Scanner struct {
	reader *csv.Reader
	record []string
	err    error

	continueOnError bool
}

// NewScanner returns a Scanner that reads from reader, configured
// with the provided options.
func NewScanner(reader io.Reader, options ...Option) *Scanner {
	return new(Scanner).initialize(reader).configure(options)
}
func (this *Scanner) initialize(reader io.Reader) *Scanner {
	this.reader = csv.NewReader(reader)
	return this
}
func (this *Scanner) configure(options []Option) *Scanner {
	for _, configure := range options {
		configure(this)
	}
	return this
}

// Scan advances the Scanner to the next record, which will then be available
// through the [Scanner.Record] method. It returns false when the scan stops,
// either by reaching the end of the input or an error. After Scan returns
// false, the [Scanner.Error] method will return any error that occurred
// during scanning, except that if it was io.EOF, Error will return nil.
func (this *Scanner) Scan() bool {
	if this.eof() {
		return false
	}
	this.record, this.err = this.reader.Read()
	return !this.eof()
}

func (this *Scanner) eof() bool {
	if this.err == io.EOF {
		return true
	}
	if this.err == nil {
		return false
	}
	return !this.continueOnError
}

// Record returns the most recent record generated by a call to Scan as a
// []string.
//
// See the [ReuseRecord] Option and follow the link to the standard library
// for details on the strategy for reusing the underlying array.
func (this *Scanner) Record() []string {
	return this.record
}

// Error returns the last non-nil error produced by Scan (if there was one).
// It will never return io.EOF. This method may be called at any point
// during or after scanning but the underlying err will be reset by each call
// to Scan.
func (this *Scanner) Error() error {
	if this.err == io.EOF {
		return nil
	}
	return this.err
}
