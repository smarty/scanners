package csv

import (
	"fmt"
	"log"
	"strings"
)

// ColumnScanner uses a [Scanner] to provide access to the fields of
// CSV-encoded data by column name. The scanner assumes the first
// record in the data to be the header with column names. If
// duplicate names exist in the header, the last column for the
// duplicate name will be used.
type ColumnScanner struct {
	*Scanner
	headerRecord  []string
	columnIndex   map[string]int
	toUpperHeader bool
}

// ColumnOpt is a func type received by NewColumnScanner.
// Each one allows configuration of the column scanner.
type ColumnOpt func(*ColumnScanner)

// ColumnOpts (a singleton instance) provides access to built-in
// functional options.
var ColumnOpts columnOpts

type columnOpts struct{}

// ToUpperHeader calls [strings.ToUpper] on each of the header column names.
func (columnOpts) ToUpperHeader() ColumnOpt {
	return func(s *ColumnScanner) {
		s.toUpperHeader = true
	}
}

// Header sets the column names used to reference the data.
// If this ColumnOpt is given then the ColumnScanner assumes the
// first record in the data is *not* a header.
func (columnOpts) Header(header []string) ColumnOpt {
	return func(s *ColumnScanner) {
		s.headerRecord = header
	}
}

// NewColumnScanner returns a ColumnScanner that reads from scanner,
// configured with the provided options, and assumes the first record
// to be the header. It calls Scan once to read the header; subsequent
// calls to Scan will return the remaining records.
func NewColumnScanner(scanner *Scanner, options ...ColumnOpt) (*ColumnScanner, error) {
	if !scanner.Scan() {
		return nil, scanner.Error()
	}
	cs := &ColumnScanner{
		Scanner:      scanner,
		headerRecord: scanner.Record(),
		columnIndex:  make(map[string]int),
	}
	cs.configure(options)
	cs.readHeader()
	return cs, nil
}
func (this *ColumnScanner) configure(options []ColumnOpt) {
	for _, configure := range options {
		configure(this)
	}
}

func (this *ColumnScanner) readHeader() {
	for i := range this.headerRecord {
		if this.toUpperHeader {
			this.headerRecord[i] = strings.ToUpper(this.headerRecord[i])
		}
		this.columnIndex[this.headerRecord[i]] = i
	}
}

// Header returns the header record.
func (this *ColumnScanner) Header() []string {
	return this.headerRecord
}

// ColumnErr returns the value for column name of the most recent
// record generated by a call to Scan as a string. It returns an
// error if column was not present in the header record.
func (this *ColumnScanner) ColumnErr(column string) (string, error) {
	index, ok := this.columnIndex[column]
	if !ok {
		return "", fmt.Errorf("Column [%s] not present in header record: %#v\n", column, this.headerRecord)
	}
	return this.Record()[index], nil
}

// Column wraps [ColumnScanner.ColumnErr], but panics if the
// name was not present in the header record.
func (this *ColumnScanner) Column(column string) string {
	value, err := this.ColumnErr(column)
	if err != nil {
		log.Panic(err)
	}
	return value
}
