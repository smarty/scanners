package csv

import (
	"fmt"
	"io"
	"log"
)

// ColumnScanner provides access to the fields of CSV-encoded
// data by column name.  The scanner assumes the first
// record in the data to be the header with column names.  If
// duplicate names exist in the header, the last column for the
// duplicate name will be used.
//
// All configurations of the underlying *csv.Reader are available
// through an [Option].
type ColumnScanner struct {
	*Scanner
	headerRecord []string
	columnIndex  map[string]int
}

// NewColumnScanner returns a ColumnScanner that reads from reader,
// configured with the provided options, and assumes the first record
// to be the header.  It calls Scan once to read the header; subsequent
// calls to Scan will return the remaining records.
func NewColumnScanner(reader io.Reader, options ...Option) (*ColumnScanner, error) {
	inner := NewScanner(reader, append(options, Options.FieldsPerRecord(0))...)
	if !inner.Scan() {
		return nil, inner.Error()
	}
	scanner := &ColumnScanner{
		Scanner:      inner,
		headerRecord: inner.Record(),
		columnIndex:  make(map[string]int),
	}
	scanner.readHeader()
	return scanner, nil
}

func (this *ColumnScanner) readHeader() {
	for i, value := range this.headerRecord {
		this.columnIndex[value] = i
	}
}

// Header returns the header record.
func (this *ColumnScanner) Header() []string {
	return this.headerRecord
}

// ColumnErr returns the value for column name of the most recent
// record generated by a call to Scan as a string.  It returns an
// error if column was not present in the header record.
func (this *ColumnScanner) ColumnErr(column string) (string, error) {
	index, ok := this.columnIndex[column]
	if !ok {
		return "", fmt.Errorf("Column [%s] not present in header record: %#v\n", column, this.headerRecord)
	}
	return this.Record()[index], nil
}

// Column wraps [ColumnScanner.ColumnErr], but panics if the name was not present
// in the header record.
func (this *ColumnScanner) Column(column string) string {
	value, err := this.ColumnErr(column)
	if err != nil {
		log.Panic(err)
	}
	return value
}
